##############################################
# 正規表現の使い方
##############################################

# 正規表現は２つに分けて考えると楽です。
# １．引っ掛けたい条件（パターン）を作る

r_hoge = /hoge/

# ２．文字列に対して１の条件（パターン）があうかみる

# マッチした場合は、MatchDataオブジェクトが返ります

p "hoge".match(r_hoge)
# => #<MatchData "hoge">

# マッチした部分を取り出したい場合は [0] で取得できます

p "hoge".match(r_hoge)[0]
# => "hoge"

# マッチしなかった場合は、nilが返ります

p "hog".match(r_hoge)
# => nil


##############################################
# 正規表現で数値だけのマッチング
##############################################

# 一文字だけのマッチングしていればいい場合

p "3aa".match(/[0-9]/)
# => #<MatchData "3">

# 全て数字のマッチングの場合
# +は１回以上の繰り返しという意味ですので、数値の１回以上の繰り返しのパターンとなります

p "333".match(/[0-9]+/)
# => #<MatchData "333">

# 省略記法で書いた場合

p "333".match(/\d+/)
# => #<MatchData "333">

##############################################
# 正規表現とメタ文字について
##############################################

# メタ文字一覧

# ( ) [ ] { } . ? + * | \

# ( ) の使い方　ついでに . の使い方

# ( ) はそこでくくったパターンを抜き出してMatchDataの[1] 以降に詰めます
# . は任意のどんな一文字でも良いというパターンになります

p "ho3ge".match(/ho(.)ge/)
# => #<MatchData "ho3ge" 1:"3">

p "ho3ge".match(/ho(.)ge/)[1]
# => "3"

# ( ) が複数個ある場合でも [1]から順番に詰められます

p "ho3ge".match(/ho(.)(ge)/)
# => #<MatchData "ho3ge" 1:"3" 2:"ge">

# [ ] の 使い方

# [ ] は範囲指定で使われます

# [a-z] はアルファベットのaからzまでのいずれかに１文字合致していれば良いというパターンになります

p "hoge".match(/[a-z]/)
# => #<MatchData "h">

# 当然合致しなければnilになります

p "333".match(/[a-z]/)
# => nil

# アルファベット以外にも以下のような使い方もできます
# [0-9] 数値の 0,1,2,3,4,5,6,7,8,9
# [A-Z] 大文字のアルファベットの A~Z

# { } の使い方

# { } は何回繰り返したかを指定できます

# 数値が３回繰り返されているパターンとなります
# （[0-9]は一文字の数値という意味でしたね）

p "333".match(/[0-9]{3}/)
# => #<MatchData "333">

# ? * + の使い方

# ? は0回もしくは１回合致するパターンになります

# １回合致した場合

p "hoge".match(/h?oge/)
# => #<MatchData "hoge">

# 0回合致した場合

p "oge".match(/h?oge/)
# => #<MatchData "oge">

# * は0回以上に合致するパターンになります

# ３回合致した場合

p "333".match(/[0-9]*/)
# => #<MatchData "333">

# ０回合致した場合

p "333".match(/4*/)
# => #<MatchData "">

# + は１回以上合致するパターンになります

p "333".match(/[0-9]+/)
# => #<MatchData "333">

# １回以上合致しないといけないので一つも合致しない下記はnilが返ります

p "333".match(/4+/)
# => nil

# | の使い方
# | は　またはでいずれかの条件に合致すればいいパターンになります

# hogeからhugaどちらかに合致すればいいパターンです

p "hoge".match(/hoge|huga/)
# => #<MatchData "hoge">

p "huga".match(/hoge|huga/)
# => #<MatchData "huga">

# \ の使い方
# \ はエスケープで使用され、今まで使ってきたメタ文字を文字として扱いたい場合に使います

# 通常に [ だけを書くとメタ文字として扱われてしまうので、 \[ と書くことで [ という文字に合致するパターンにできます

p "[".match(/\[/)
# => #<MatchData "[">
