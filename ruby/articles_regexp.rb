##############################################
# 正規表現の使い方
##############################################

# 正規表現は２つに分けて考えると楽です。
# １．引っ掛けたい条件（パターン）を作る

r_hoge = /hoge/

# ２．文字列に対して１の条件（パターン）があうかみる

# マッチした場合は、MatchDataオブジェクトが返ります

p "hoge".match(r_hoge)
# => #<MatchData "hoge">

# マッチした部分を取り出したい場合は [0] で取得できます

p "hoge".match(r_hoge)[0]
# => "hoge"

# マッチしなかった場合は、nilが返ります

p "hog".match(r_hoge)
# => nil

##############################################
# 正規表現で数値だけのマッチング
##############################################

# 一文字だけのマッチングしていればいい場合

p "3aa".match(/[0-9]/)
# => #<MatchData "3">

# 全て数字のマッチングの場合
# +は１回以上の繰り返しという意味ですので、数値の１回以上の繰り返しのパターンとなります

p "333".match(/[0-9]+/)
# => #<MatchData "333">

# 省略記法で書いた場合

p "333".match(/\d+/)
# => #<MatchData "333">

##############################################
# 正規表現とメタ文字について
##############################################

# メタ文字一覧

# ( ) [ ] { } . ? + * | \

# ( ) の使い方　ついでに . の使い方

# ( ) はそこでくくったパターンを抜き出してMatchDataの[1] 以降に詰めます
# . は任意のどんな一文字でも良いというパターンになります

p "ho3ge".match(/ho(.)ge/)
# => #<MatchData "ho3ge" 1:"3">

p "ho3ge".match(/ho(.)ge/)[1]
# => "3"

# ( ) が複数個ある場合でも [1]から順番に詰められます

p "ho3ge".match(/ho(.)(ge)/)
# => #<MatchData "ho3ge" 1:"3" 2:"ge">

# [ ] の 使い方

# [ ] は範囲指定で使われます

# [a-z] はアルファベットのaからzまでのいずれかに１文字合致していれば良いというパターンになります

p "hoge".match(/[a-z]/)
# => #<MatchData "h">

# 当然合致しなければnilになります

p "333".match(/[a-z]/)
# => nil

# アルファベット以外にも以下のような使い方もできます
# [0-9] 数値の 0,1,2,3,4,5,6,7,8,9
# [A-Z] 大文字のアルファベットの A~Z

# { } の使い方

# { } は何回繰り返したかを指定できます

# 数値が３回繰り返されているパターンとなります
# （[0-9]は一文字の数値という意味でしたね）

p "333".match(/[0-9]{3}/)
# => #<MatchData "333">

# ? * + の使い方

# ? は0回もしくは１回合致するパターンになります

# １回合致した場合

p "hoge".match(/h?oge/)
# => #<MatchData "hoge">

# 0回合致した場合

p "oge".match(/h?oge/)
# => #<MatchData "oge">

# * は0回以上に合致するパターンになります

# ３回合致した場合

p "333".match(/[0-9]*/)
# => #<MatchData "333">

# ０回合致した場合

p "333".match(/4*/)
# => #<MatchData "">

# + は１回以上合致するパターンになります

p "333".match(/[0-9]+/)
# => #<MatchData "333">

# １回以上合致しないといけないので一つも合致しない下記はnilが返ります

p "333".match(/4+/)
# => nil

# | の使い方
# | は　またはでいずれかの条件に合致すればいいパターンになります

# hogeからhugaどちらかに合致すればいいパターンです

p "hoge".match(/hoge|huga/)
# => #<MatchData "hoge">

p "huga".match(/hoge|huga/)
# => #<MatchData "huga">

# \ の使い方
# \ はエスケープで使用され、今まで使ってきたメタ文字を文字として扱いたい場合に使います

# 通常に [ だけを書くとメタ文字として扱われてしまうので、 \[ と書くことで [ という文字に合致するパターンにできます

p "[".match(/\[/)
# => #<MatchData "[">

##############################################
# 正規表現で英字だけのマッチング
##############################################

# 小文字でかつ一文字だけのマッチングしていればいい場合

p "3aa".match(/[a-z]/)
# => #<MatchData "a">

# 全て小文字の英字のマッチングの場合
# +は１回以上の繰り返しという意味ですので、数値の１回以上の繰り返しのパターンとなります

p "aiu".match(/[a-z]+/)
# => #<MatchData "aiu">

# 大文字小文字あわせた英字のマッチングの場合

p "3aiueAIUE".match(/[a-zA-z]+/)
#<MatchData "aiueAIUE">

##############################################
# 正規表現で省略記法での英数字だけのマッチング
##############################################

# 英数字とのマッチング
# 英数字は省略記法で \wになります
# +は１回以上の繰り返しという意味ですので、数値の１回以上の繰り返しのパターンとなります
# ただしこの記法はアンダーバー（_） もマッチングに含まれてしまうので注意してください
# 厳密に行いたい場合は [a-zA-Z0-9] などを使ってください
p "3aiue_%$#".match(/\w+/)
#<MatchData "3aiue_">

##############################################
# 正規表現で置換、一部と全置換(sub gsub)
##############################################

# 正規表現で一部を置換する場合

# subは最初に見つけたパターンにマッチングしたものだけを対象にして置換を行います
# この場合 最初に3を見つけたのでそれだけを変換します
p "333".sub(/3/, '4')
# => "433"

# 正規表現で全置換する場合

# gsubはすべての文字を繰り返しパターンにマッチングするかどうかみて置換を行います
# ですので、3が全て4に変わっています

p "333".gsub(/3/, '4')
# => "444"

##############################################
# 正規表現で前方一致と後方一致
##############################################

# 前方一致
# ^ は文字の始まりを意味します
# 下記は最初がaから始まっていないためマッチしません

p "aiueo".match(/^iue/)
# => nil

# こちらはaから始まっているのでマッチします

p "aiueo".match(/^aiu/)
# => #<MatchData "aiu">

# 後方一致
# $ は文字の終わりを意味します

p "aiueo".match(/ueo$/)
# => #<MatchData "ueo">

# マッチしているかどうかtrueかfalseだけ返ってくればいい場合

# 前方一致している場合にtrueをそうでない場合falseを返します

p "aiueo".start_with?("aiu")
# => true

# 後方一致している場合にtrueをそうでない場合falseを返します

p "aiueo".end_with?("hoge")
# => false

p "aiueo".end_with?("ueo")
# => true

